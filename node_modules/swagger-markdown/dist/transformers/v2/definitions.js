"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformDefinition = exports.processDefinition = void 0;
const dataTypes_1 = require("./dataTypes");
const Schema_1 = require("./models/Schema");
const markdown_1 = require("../../lib/markdown");
const mdtable_1 = require("../../lib/markdown/mdtable");
/**
 * Parse the Property field if present.
 * @param name of the definition
 * @param definition definition object
 */
function parseProperties(definition) {
    const rows = [];
    const md = markdown_1.Markdown.md();
    const required = 'required' in definition ? definition.required : [];
    // const res = [];
    Object.keys(definition.properties).forEach((propName) => {
        const tr = mdtable_1.MDtableRow.tr();
        const prop = definition.properties[propName];
        const typeCell = (0, dataTypes_1.dataTypeResolver)(new Schema_1.Schema(prop));
        const descriptionParts = [];
        if ('description' in prop) {
            descriptionParts.push(md.string(prop.description.replace(/[\r\n]/g, ' ')).escape().get());
        }
        if ('enum' in prop) {
            const enumValues = prop.enum.map((val) => `\`${JSON.stringify(val)}\``).join(', ');
            descriptionParts.push(md.string('Enum:').italic().concat(` ${enumValues}`).get());
        }
        if ('example' in prop) {
            descriptionParts.push(md.string('Example:').italic().concat(` \`${JSON.stringify(prop.example)}\``).get());
        }
        const descriptionCell = descriptionParts.join('<br>');
        const requiredCell = required.includes(propName) ? 'Yes' : 'No';
        tr.td(propName).td(typeCell).td(descriptionCell).td(requiredCell);
        rows.push(tr);
    });
    return rows;
}
/**
 * Parse allOf definition
 * @param name of the definition
 * @param definition definition object
 */
function parsePrimitive(name, definition) {
    const tr = mdtable_1.MDtableRow.tr();
    const typeCell = 'type' in definition ? definition.type : '';
    const descriptionCell = ('description' in definition ? definition.description : '').replace(/[\r\n]/g, ' ');
    const requiredCell = '';
    tr.td(name)
        .td(Array.isArray(typeCell) ? typeCell.join(', ') : typeCell)
        .td(descriptionCell)
        .td(requiredCell);
    return tr;
}
/**
 * @param {type} name
 * @param {type} definition
 * @return {type} Description
 */
function processDefinition(name, definition) {
    const md = markdown_1.Markdown.md();
    md.line()
        .line(md.string(name).h4())
        .line();
    if (definition.description) {
        md.line(definition.description)
            .line();
    }
    const table = md.table();
    table.th('Name').th('Type').th('Description').th('Required');
    if ('properties' in definition) {
        const parsedProperties = (parseProperties(definition));
        parsedProperties.forEach((row) => table.insertRow(row));
    }
    else {
        table.insertRow(parsePrimitive(name, definition));
    }
    md.line(table);
    if (definition.example) {
        const formattedExample = typeof definition.example === 'string'
            ? definition.example
            : JSON.stringify(definition.example, null, '  ');
        md.line()
            .line(md.string('Example').bold())
            .line(`<pre>${formattedExample}</pre>`);
    }
    return md.export();
}
exports.processDefinition = processDefinition;
/**
 * @param {type} definitions
 * @return {type} Description
 */
function transformDefinition(definitions) {
    let hasDefinitions = false;
    const md = markdown_1.Markdown.md();
    md
        .line(md.string('Models').h3())
        .line();
    Object.keys(definitions).forEach((definitionName) => {
        const processedDefinition = processDefinition(definitionName, definitions[definitionName]);
        if (processedDefinition) {
            hasDefinitions = true;
            md.line(processedDefinition);
        }
    });
    if (hasDefinitions) {
        return md.export();
    }
    return null;
}
exports.transformDefinition = transformDefinition;
