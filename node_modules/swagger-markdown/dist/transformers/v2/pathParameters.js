"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformParameters = void 0;
const dataTypes_1 = require("./dataTypes");
const Schema_1 = require("./models/Schema");
const markdown_1 = require("../../lib/markdown");
const transformParameters = (parameters, pathParameters) => {
    const md = markdown_1.Markdown.md();
    md.line(md.string('Parameters').h5()).line();
    const table = md.table();
    table.th('Name').th('Located in').th('Description').th('Required')
        .th('Schema');
    [].concat(pathParameters, parameters).forEach((keys) => {
        if (keys) {
            const tr = table.tr();
            // Name first
            tr.td(keys.name || '');
            // Scope (in)
            tr.td(keys.in || '');
            // description
            if ('description' in keys) {
                tr.td(md.string(keys.description.replace(/[\r\n]/g, ' ')).escape());
            }
            else {
                tr.td('');
            }
            tr.td(keys.required ? 'Yes' : 'No');
            // Prepare schema to be transformed
            let schema = null;
            if ('schema' in keys) {
                schema = new Schema_1.Schema(keys.schema);
            }
            else {
                schema = new Schema_1.Schema();
                schema.setType('type' in keys ? keys.type : null);
                schema.setFormat('format' in keys ? keys.format : null);
                schema.setReference('$ref' in keys ? keys.$ref : null);
                schema.setItems('items' in keys ? keys.items : null);
            }
            tr.td((0, dataTypes_1.dataTypeResolver)(schema));
        }
    });
    md.line(table);
    return md.export();
};
exports.transformParameters = transformParameters;
