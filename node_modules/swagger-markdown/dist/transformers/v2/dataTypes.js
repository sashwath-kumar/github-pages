"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.dataTypeResolver = exports.resolveType = void 0;
const anchor_1 = require("../../lib/anchor");
const markdown_1 = require("../../lib/markdown");
const resolver = {
    integer: {
        int32: 'integer',
        int64: 'long',
    },
    number: {
        float: 'float',
        double: 'double',
    },
    string: {
        byte: 'byte',
        binary: 'binary',
        date: 'date',
        'date-time': 'dateTime',
        password: 'password',
    },
};
function resolveType(type, format) {
    if (type in resolver) {
        if (format) {
            return format in resolver[type]
                ? resolver[type][format]
                : `${type} (${format})`;
        }
        return type;
    }
    return undefined;
}
exports.resolveType = resolveType;
/**
 * Transform data types into common names
 * @param {Schema} schema
 * @return {String}
 */
const dataTypeResolver = (schema) => {
    const md = markdown_1.Markdown.md();
    const all = schema.getAllOf();
    if (all) {
        return all.map((subSchema) => (0, exports.dataTypeResolver)(subSchema))
            .filter((type) => type !== '')
            .join(' & ');
    }
    const reference = schema.getReference();
    if (reference) {
        const name = reference.match(/\/([^/]*)$/i)[1];
        const link = (0, anchor_1.anchor)(name);
        return md.string().link(name, `#${link}`).get();
    }
    // Cast it to the array
    const schemaType = schema.getType();
    const types = Array.isArray(schemaType) ? schemaType : [schemaType];
    const format = schema.getFormat();
    const resolveResults = types.map((type) => {
        if (type in resolver) {
            if (format) {
                return format in resolver[type]
                    ? resolver[type][format]
                    : `${type} (${format})`;
            }
            return type;
        }
        if (format) {
            return `${type} (${format})`;
        }
        if (type === 'array') {
            const subType = (0, exports.dataTypeResolver)(schema.getItems());
            return `[ ${subType} ]`;
        }
        // If schema has properties, it means that type is object
        // we can simply skip this check, furthemore some yaml files may just miss it
        if (Object.keys(schema.properties).length > 0) {
            const { properties } = schema;
            const values = Object.values(properties).map((p) => (0, exports.dataTypeResolver)(p));
            const keys = Object.keys(properties);
            const pairs = [];
            for (let i = 0; i < keys.length; i++) {
                pairs.push(md.string(`"${keys[i]}"`)
                    .bold()
                    .concat(`: ${values[i]}`).get());
            }
            return `{ ${pairs.join(', ')} }`;
        }
        if (type) {
            return md.string(type).get();
        }
        return md.string('').get();
    }).filter((s) => s.length > 0); // and filter out empty strings
    return md.string(resolveResults.join(', ')).get();
};
exports.dataTypeResolver = dataTypeResolver;
